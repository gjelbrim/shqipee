import "./chunk-UGBVNEQM.js";

// node_modules/svelte-copy/dist/copy.js
async function copyText(text) {
  if ("clipboard" in navigator) {
    await navigator.clipboard.writeText(text);
  } else {
    const element = document.createElement("input");
    element.type = "text";
    element.disabled = true;
    element.style.setProperty("position", "fixed");
    element.style.setProperty("z-index", "-100");
    element.style.setProperty("pointer-events", "none");
    element.style.setProperty("opacity", "0");
    element.value = text;
    document.body.appendChild(element);
    element.click();
    element.select();
    document.execCommand("copy");
    document.body.removeChild(element);
  }
}
function parseOptions(options) {
  return typeof options == "string" ? { text: options } : options;
}
function addListeners(element, cb, events = ["click"]) {
  for (const event of events) {
    element.addEventListener(event, cb, true);
  }
}
function removeListeners(element, cb, events = ["click"]) {
  for (const event of events) {
    element.removeEventListener(event, cb, true);
  }
}
var copy = (element, initialOptions) => {
  let options = parseOptions(initialOptions);
  const handle = async (event) => {
    var _a, _b;
    const text = options.text;
    try {
      await copyText(text);
      (_a = options.onCopy) == null ? void 0 : _a.call(options, { text, event });
    } catch (e) {
      const error = new Error(`${e instanceof Error ? e.message : e}`, {
        cause: e
      });
      (_b = options.onError) == null ? void 0 : _b.call(options, { error, event });
    }
  };
  addListeners(element, handle, options.events);
  return {
    update(newOptions) {
      removeListeners(element, handle, options.events);
      options = parseOptions(newOptions);
      addListeners(element, handle, options.events);
    },
    destroy() {
      removeListeners(element, handle, options.events);
    }
  };
};
export {
  copy,
  copyText
};
//# sourceMappingURL=svelte-copy.js.map
